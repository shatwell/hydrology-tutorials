<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tom Shatwell">
<meta name="dcterms.date" content="2025-04-04">

<title>Auswertung Wasserstand und Abfluss</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="uebung5_de_files/libs/clipboard/clipboard.min.js"></script>
<script src="uebung5_de_files/libs/quarto-html/quarto.js"></script>
<script src="uebung5_de_files/libs/quarto-html/popper.min.js"></script>
<script src="uebung5_de_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="uebung5_de_files/libs/quarto-html/anchor.min.js"></script>
<link href="uebung5_de_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="uebung5_de_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="uebung5_de_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="uebung5_de_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="uebung5_de_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Auswertung Wasserstand und Abfluss</h1>
<p class="subtitle lead">Hydrologie und Wasserbau - Übung 5</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Tom Shatwell </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 4, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="einführung" class="level1">
<h1>Einführung</h1>
<p>In dieser Übung werden Sie Wasserstand- und Abflussdaten von drei hydrologischen Stationen an Bächen in Bayern auswerten. Die Aufgaben, die Sie durchführen werden, umfassen:</p>
<ul>
<li>Importieren und Visualisieren der Daten</li>
<li>Untersuchung der Schluesselkurve (Wasserstand-Abfluss-Beziehung)</li>
<li>Überprüfung der Homogenität der Daten</li>
<li>Darstellung einiger wichtiger Kurven, die die Daten charakterisieren</li>
<li>Schätzung des Abflusses an einem Zwischenstandort für ein Bauprojekt</li>
</ul>
<p>Die Aufgaben können alle durch Anpassung des im Beispiel gezeigten Codes oder durch Interpretation der Diagramme gelöst werden.</p>
<p>Das Ziel ist, Sie mit einigen statistischen Methoden vertraut zu machen, die häufig in der Hydrologie verwendet werden, den Umgang mit R zu üben und Ihnen einen Eindruck von der Arbeit mit echten hydrologischen Daten zu vermitteln.</p>
<section id="der-datensatz" class="level2">
<h2 class="anchored" data-anchor-id="der-datensatz">Der Datensatz</h2>
<p>Der Datensatz stammt von zwei Bächen, die etwa 30 km nördlich der Stadt Bayreuth in Bayern liegen. Die Daten wurden vom <a href="https://www.gkd.bayern.de/">Geoportal des Gewässerkundlichen Dienstes Bayern</a> des <a href="https://www.lfu.bayern.de/index.htm">Bayerischen Landesamts für Umwelt</a> heruntergeladen, das diese unter der <a href="https://creativecommons.org/licenses/by/4.0/deed.en">CC-BY 4.0 Lizenz</a> bereitstellt, welche die weitere Nutzung der Daten regelt. Dem Bayerischen Landesamt für Umwelt wird herzlich für das Sammeln und Bereitstellen der Daten gedankt.</p>
<p>Die Daten befinden sich in der Datei <code>schorgast_wasserstand_abfluss.csv</code> im Kursordner. Die Daten bestehen aus täglichen Messungen des Wasserstands (W) in cm über dem Pegelnullpunkt und des Abflusses (Q) in <span class="math inline">\(\mathrm{m^3 s^{-1}}\)</span> von drei Pegelstationen:</p>
<ul>
<li>am Bach Schorgast in Wirsberg (Station 1)</li>
<li>am Bach Untere-Steinach in Untersteinach (Station 2)</li>
<li>am Bach Schorgast in Untersteinach unterhalb der Mündung des Untere-Steinach-Bachs (Station 3).</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../figs/schorgast-untersteinach2.png" class="center img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Stream network and location of hydrological stations</figcaption>
</figure>
</div>
<p>Die Überschriften W1-W3 und Q1-Q3 beziehen sich auf den Wasserstand und den Abfluss an den Stationen 1-3 entsprechend. Die ursprünglichen Daten wurden leicht modifiziert, indem sie auf denselben Zeitraum gekürzt wurden, und fehlende Abflussmessungen (Jan - Okt 1982) an Station 2 wurden basierend auf den Daten der beiden anderen Stationen geschätzt.</p>
<p>Die Daten sind in dieser Form unter <a href="https://" class="uri">https://</a> oder im Kursordner verfügbar. Zusätzliche Informationen zu den Daten sind in der Datei <code>readme-steinach-schorgast.txt</code> im Kursordner enthalten.</p>
</section>
<section id="pakete" class="level2">
<h2 class="anchored" data-anchor-id="pakete">Pakete</h2>
<p>Laden Sie zuerst die notwendigen Pakete für Ihre neue R-Session.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readr)     <span class="co"># modernized functions to read rectangular data like csv</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)     <span class="co"># the most essential tidyverse packages</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)     <span class="co"># contains for example pivot tables</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lubridate) <span class="co"># a tidyverse package for dates</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)   <span class="co"># high level plotting with the grammar of graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="importieren-und-visualisieren-der-daten" class="level1">
<h1>Importieren und Visualisieren der Daten</h1>
<p>Bevor Daten in R importiert werden, ist es hilfreich, das aktuelle Arbeitsverzeichnis mit <code>getwd()</code> zu überprüfen und die Datei in einem Texteditor zu öffnen, um die Struktur der Daten zu prüfen. Beispielsweise: Welche Spalten gibt es? Wie sind sie formatiert (z. B. Datumsangaben, Dezimalzahlen, Text)? Wie sind die Spalten getrennt? Gibt es zusätzliche Zeilen oberhalb der Daten? Enthalten die Überschriften Sonderzeichen, die in R Probleme verursachen könnten? Es kann einfacher sein, solche Probleme manuell zu beheben, bevor die Datei importiert wird.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../figs/schorgast-csv-header.PNG" class="left img-fluid figure-img" style="width:40.0%"></p>
<figcaption>Inhalt der ersten Zeilen der Datei “schorgast_wasserstand_abfluss.csv”</figcaption>
</figure>
</div>
<p>In diesem Fall haben wir eine Datei mit einer Kopfzeile, die erste Spalte enthält ein Datum im Format YYYY-MM-DD, und die Spalten sind durch Kommas getrennt. Auf meinem Computer befindet sich die Datei eine Ebene höher <code>../</code> vom aktuellen Arbeitsverzeichnis aus und von dort im Unterverzeichnis <code>Daten/</code>. Wir verwenden <code>read_csv()</code> aus dem <code>readr</code>-Paket und weisen (<code>&lt;-</code>) die Daten der Variable <code>schorgast</code> zu.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>schorgast <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"../data/schorgast_wasserstand_abfluss.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Alternativ können Sie die Daten manuell über File -&gt; Import dataset -&gt; from text (readr) importieren</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../figs/import-screenshot.png" class="img-fluid figure-img"></p>
<figcaption>Daten in RStudio manuell importieren über Datei-Menü</figcaption>
</figure>
</div>
<p>Als Nächstes inspizieren wir die Daten, um die Spaltennamen und Datentypen zu überprüfen. Anschließend werden die Daten visualisiert.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(schorgast)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 7
  Datum         W1    Q1    W2    Q2    W3    Q3
  &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 1968-01-01   136  1.9     NA  3.68   169  6.55
2 1968-01-02   135  1.71    NA  3.21   162  6.1 
3 1968-01-03   134  1.62    NA  2.8    157  5.61
4 1968-01-04   133  1.52    NA  2.64   153  5.36
5 1968-01-05   132  1.43    NA  2.48   147  4.83
6 1968-01-06   140  2.19    NA  4.87   184  7.76</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(schorgast<span class="sc">$</span>Datum)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Date"</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Q1 <span class="sc">~</span> Datum, <span class="at">data =</span> schorgast, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-discharge-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Falls die Spalte <code>Datum</code> nicht vom Typ (class) <code>Date</code> ist, werden Sie Schwierigkeiten haben, die Daten zu plotten.</p>
<section id="aufgabe-1" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-1">Aufgabe 1</h2>
<ul>
<li>Plotten Sie die Ganglinien für den Wasserstand (W) und den Abfluss (Q) für die Stationen 1 bis 3.</li>
<li>Gibt es fehlende Daten?</li>
<li>Welche Station hat den größten Abfluss? Warum?</li>
</ul>
</section>
</section>
<section id="überprüfung-der-homogenität-der-daten" class="level1">
<h1>Überprüfung der Homogenität der Daten</h1>
<p>Viele statistische Tests und Analysen von hydrologischen Daten setzen voraus, dass die Daten homogen sind. Daten sind homogen, wenn sie konsistent und stationär sind und keine allmählichen oder plötzlichen Änderungen aufweisen, die oft visuell schwer zu erkennen sind. Solche Änderungen könnten durch eine Veränderung der Landnutzung im Einzugsgebiet oder durch eine Änderung der Messmethodik verursacht werden. Eine schnelle und einfache Möglichkeit, dies zu überprüfen, ist der <strong>Doppelsummentest</strong>, der zusätzliche hydrologische Zeitreihen aus einem nahegelegenen Einzugsgebiet erfordert. Dieser Test deckt jedoch keine Inhomogenitäten auf, die beide Einzugsgebiete gleichzeitig betreffen, wie zum Beispiel den Klimawandel.</p>
<p>Der Doppelsummentest beinhaltet das Aufsummieren der täglichen Abflussmessungen an zwei Stationen für denselben Zeitraum und das Plotten der Summen gegeneinander. Wenn der Plot eine gerade Linie ergibt, sehen die Daten homogen aus. Ein Knick in der Kurve deutet auf eine plötzliche Änderung in den Daten hin, eine Änderung der Steigung weist auf eine allmähliche oder systematische Veränderung hin. Die R-Funktion <code>cumsum()</code> berechnet die kumulative Summe der Messwerte (d.&nbsp;h. q1, q1+q2, q1+q2+q3, …).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
</div>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cumsum</span>(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1  3  6 10 15 21 28 36 45 55</code></pre>
</div>
</div>
<p>Wir plotten die Doppelsumme für die Stationen 1 und 2 unter Verwendung der Spalten Q1 und Q2. Fügen Sie einige Achsenbeschriftungen mit <code>xlab</code> und <code>ylab</code> hinzu. Anschließend führen wir eine einfache lineare Regression mit der Funktion <code>lm()</code> durch, um eine Linie durch die Daten zu plotten. Die Linie wird mit der Funktion <code>abline()</code> dem Plot hinzugefügt, wobei die Farbe auf Rot geändert wird (<code>col = "red"</code>) und die Linienbreite auf das Doppelte des Standards gesetzt wird (<code>lwd = 2</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>sum1 <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(schorgast<span class="sc">$</span>Q1)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>sum2 <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(schorgast<span class="sc">$</span>Q2)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sum2 <span class="sc">~</span> sum1, <span class="at">xlab=</span><span class="st">"Station 1"</span>, <span class="at">ylab=</span><span class="st">"Station 2"</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>reg1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(sum2 <span class="sc">~</span> sum1)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(reg1, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-cumsums-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Die Linie sieht anfangs ziemlich gerade aus, da die schwarzen Punkte der roten Linie sehr eng folgen. Aber was passiert, wenn wir die Regression nur auf den ersten Teil der Reihe beschränken, sagen wir auf das erste Quartal, was etwa 4500 Beobachtungen entspricht?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(sum2 <span class="sc">~</span> sum1, <span class="at">xlab=</span><span class="st">"Station 1"</span>, <span class="at">ylab=</span><span class="st">"Station 2"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>reg2 <span class="ot">&lt;-</span> <span class="fu">lm</span>(sum2[<span class="dv">1</span><span class="sc">:</span><span class="dv">4500</span>] <span class="sc">~</span> sum1[<span class="dv">1</span><span class="sc">:</span><span class="dv">4500</span>])</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(reg2, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-cumsums2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Die Linie ist vielleicht nicht so gerade, wie sie zunächst erschien.</p>
<section id="aufgabe-2" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-2">Aufgabe 2</h2>
<ul>
<li>Was bedeutet die Abweichung von der Linie im obigen Plot?</li>
<li>Was könnte in den Einzugsgebieten der Stationen 1 und 2 passiert sein, um diese Abweichung zu erklären?</li>
<li>Verwenden Sie Doppelsummenplots, um die anderen Stationen zu vergleichen, d.&nbsp;h. Station 1 und 3 sowie Station 2 und 3. Erklären Sie Ihre Ergebnisse.</li>
</ul>
</section>
</section>
<section id="wasserstand-abfluss-beziehungen" class="level1">
<h1>Wasserstand-Abfluss-Beziehungen</h1>
<p>Hydrologische Stationen messen den Abfluss nicht direkt, sondern den Wasserstand. Schluesselkurven (Wasserstand-Abfluss-Beziehungen) werden verwendet, um den Abfluss aus dem Wasserstand zu berechnen. Diese Beziehungen werden definiert, indem der Abfluss bei verschiedenen Wasserständen gemessen und anschließend eine Kurve an die Messwerte angepasst wird. Die Wasserstand-Abfluss-Beziehung hängt vom Querschnitt des Flussbettes ab. Wenn sich der Querschnitt verändert, gilt die Wasserstand-Abfluss-Beziehung nicht mehr und muss neu berechnet werden.</p>
<section id="aufgabe-3" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-3">Aufgabe 3</h2>
<ul>
<li>Plotten Sie die Wasserstand-Abfluss-Beziehungen für die drei Stationen. Typischerweise wird der Wasserstand auf der (vertikalen) y-Achse und der Abfluss auf der x-Achse dargestellt. Die Plots sollten ungefähr so aussehen:</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-W-Q-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Beim Betrachten der Wasserstand-Abfluss-Kurven fällt auf, dass es ziemlich viel Rauschen geben kann. Eine feste Wasserstand-Abfluss-Kurve würde wie eine scharfe Linie aussehen, sodass möglicherweise im Laufe der Jahre unterschiedliche Wasserstand-Abfluss-Kurven verwendet wurden. Die Funktion <code>ggplot()</code> aus dem Paket <code>ggplot2</code> bietet einige hilfreiche Funktionen, um dies zu untersuchen. Zum Beispiel ist es möglich, die Punkte nach Zeit farblich zu codieren, indem man das Argument <code>colour = Datum</code> setzt. Dies weist ggplot an, die Punkte entsprechend den Werten in der Spalte <code>Datum</code> einzufärben.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> schorgast) <span class="sc">+</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x =</span> Q1, <span class="at">y =</span> W1, <span class="at">colour =</span> Datum)) <span class="sc">+</span> </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_light</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/ggplot-W-Q-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><p>Erstellen Sie einen Plot wie den oben für Station 3. Was können Sie darüber sagen, wie sich die Form der Wasserstand-Abfluss-Kurve im Laufe der Zeit verändert haben könnte?</p></li>
<li><p>Wie hat sich der Querschnitt des Flussbetts im Laufe der Zeit verändert, um diesen Effekt zu verursachen?</p></li>
<li><p>Welche hydrologischen Prozesse könnten diese Veränderungen verursacht haben?</p></li>
</ul>
</section>
</section>
<section id="dauerlinien" class="level1">
<h1>Dauerlinien</h1>
<p>Dauerlinien zeigen (wenn sie aus täglichen Abflussdaten erstellt werden), wie oft ein bestimmter Wasserstand oder Abfluss innerhalb eines bestimmten Zeitraums überschritten wird. Zum Beispiel: An wie vielen Tagen pro Jahr wird eine Abflussrate von 1,5 <span class="math inline">\(\mathrm{m^3 s^{-1}}\)</span> überschritten? Sie zeigen die Überschreitungswahrscheinlichkeit eines gemessenen Wertes.</p>
<p>Wir erstellen diese, indem wir die Werte, die uns interessieren, vom höchsten zum niedrigsten sortieren und diese Werte dann für den Zeitraum plotten, der uns interessiert.</p>
<p>Wir betrachten den Wasserstand an Station 3 (<code>W3</code>). Zuerst sortiert die Funktion <code>order()</code> die Daten vom niedrigsten zum höchsten Wert und gibt die entsprechenden Indizes zurück, die wir <code>ind</code> nennen. Danach kehrt die Funktion <code>rev()</code> diese Reihenfolge um, was wir <code>revind</code> nennen. Schließlich erstellen wir ein neues <code>data.frame</code>, das mit diesen Indizes sortiert ist.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ind <span class="ot">&lt;-</span> <span class="fu">order</span>(schorgast<span class="sc">$</span>W3)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>revind <span class="ot">&lt;-</span> <span class="fu">rev</span>(ind)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>W3_sortiert <span class="ot">&lt;-</span> schorgast[revind, ]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># in R, it is also possible to combine these steps</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>W3_sortiert <span class="ot">&lt;-</span> schorgast[<span class="fu">rev</span>(<span class="fu">order</span>(schorgast<span class="sc">$</span>W3)), ]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(W3_sortiert)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 7
  Datum         W1    Q1    W2    Q2    W3    Q3
  &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 2003-01-03   183  7.48   245  26.2   368  38.8
2 2006-05-28   196 10.4    242  24.5   354  52  
3 2011-01-14   216 13.6    264  37.6   353  57.4
4 2002-01-28   217 13.7    268  40.3   350  68.9
5 1998-11-01   205 11.5    252  30.4   350  46.7
6 1998-09-16   167  5      242  24.1   350  38.2</code></pre>
</div>
</div>
<p>Jetzt können wir eine Dauerlinie plotten. Wir fügen eine Spalte für die Wahrscheinlichkeit hinzu, die wir <code>wahrscheinlichkeit</code> nennen, und berechnen diese aus der Anzahl der Beobachtungen (<code>nzeilen</code>). Normalerweise verwenden Sie das Dollarzeichen <code>$</code>, um auf Spalten in einem <code>data.frame</code> zuzugreifen (z. B. <code>schorgast$Datum</code>). Sie können jedoch auch <code>$</code> verwenden, um Spalten zu erstellen. R überprüft, ob die Spalte existiert, und falls nicht, wird sie von R erstellt. Da die Spalte <code>wahrscheinlichkeit</code> noch nicht existiert, können wir sie mit <code>schorgast$wahrscheinlichkeit &lt;- ...</code> erstellen.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>nzeilen <span class="ot">&lt;-</span> <span class="fu">nrow</span>(W3_sortiert)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>W3_sortiert<span class="sc">$</span>wahrscheinlichkeit <span class="ot">&lt;-</span> (<span class="dv">1</span> <span class="sc">:</span> nzeilen) <span class="sc">/</span> nzeilen</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(W3<span class="sc">~</span>wahrscheinlichkeit, <span class="at">data =</span> W3_sortiert, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-dauerlinie-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Nun können Sie die Wahrscheinlichkeit berechnen, dass ein bestimmter Wasserstand an einem Tag überschritten wird. Versuchen Sie, dies manuell zu tun, indem Sie die Wahrscheinlichkeit aus der Kurve abschätzen. Sie können die Funktion <code>abline()</code> verwenden, um Linien als Orientierungshilfe zum Plot hinzuzufügen. Zum Beispiel fügt <code>abline(h = 200)</code> eine horizontale Linie bei y=200 hinzu, und <code>abline(v = c(0.2, 0.4, 0.6))</code> fügt vertikale Linien bei x = 0.2, x = 0.4 und x = 0.6 hinzu.</p>
<section id="aufgabe-4" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-4">Aufgabe 4</h2>
<ul>
<li><p>Schätzen Sie mit der oben beschriebenen Methode die Überschreitungswahrscheinlichkeit eines Wasserstands von 148 cm an Station 3.</p></li>
<li><p>Welcher Wasserstand an Station 3 wird an 10% der Tage (d.&nbsp;h. mit einer Wahrscheinlichkeit von 0,1) überschritten?</p></li>
</ul>
</section>
</section>
<section id="summenkurven" class="level1">
<h1>Summenkurven</h1>
<p>Die Summenkurve stellt die integrierte Ganglinie (Volumen) der Abflüsse dar. Sie beginnt gewöhnlich bei Null und endet bei einem Wert, der als Abfluss- oder Wasservolumen der betrachteten Periode T bezeichnet wird. Summenkurven sind wichtig für das Management von Wasserspeichern und Stauseen. Die Steigung der Kurve entspricht dem Abfluss.</p>
<p><span class="math display">\[
V_t = \int_0^t Q\, dt
\]</span></p>
<p>oder</p>
<p><span class="math display">\[
V_T = \int_0^T Q\, dt
\]</span></p>
<p>Hier berechnen wir die Summenverteilung für bestimmte Jahre. Um dies zu erleichtern, fügen wir zunächst zwei neue Spalten zu unserem Datensatz hinzu, die das Jahr der Messung und den Tag des Jahres anzeigen. Die Funktionen <code>year()</code> und <code>yday()</code> aus dem Paket <code>lubridate</code> übernehmen dies.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>schorgast<span class="sc">$</span>jahr <span class="ot">&lt;-</span> <span class="fu">year</span>(schorgast<span class="sc">$</span>Datum)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>schorgast<span class="sc">$</span>jahrtag <span class="ot">&lt;-</span> <span class="fu">yday</span>(schorgast<span class="sc">$</span>Datum)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(schorgast)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 9
  Datum         W1    Q1    W2    Q2    W3    Q3  jahr jahrtag
  &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
1 1968-01-01   136  1.9     NA  3.68   169  6.55  1968       1
2 1968-01-02   135  1.71    NA  3.21   162  6.1   1968       2
3 1968-01-03   134  1.62    NA  2.8    157  5.61  1968       3
4 1968-01-04   133  1.52    NA  2.64   153  5.36  1968       4
5 1968-01-05   132  1.43    NA  2.48   147  4.83  1968       5
6 1968-01-06   140  2.19    NA  4.87   184  7.76  1968       6</code></pre>
</div>
</div>
<p>Da wir tägliche Daten haben, ist <span class="math inline">\(dt = 1\)</span> Tag. Das bedeutet, dass wir <span class="math inline">\(V_T\)</span> einfach durch das Aufsummieren der Messwerte mit <code>cumsum()</code> berechnen können.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>schorgast <span class="ot">&lt;-</span> schorgast <span class="sc">|&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(jahr) <span class="sc">|&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">summeQ1 =</span> <span class="fu">cumsum</span>(Q1))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(schorgast)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 10
# Groups:   jahr [1]
  Datum         W1    Q1    W2    Q2    W3    Q3  jahr jahrtag summeQ1
  &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
1 1968-01-01   136  1.9     NA  3.68   169  6.55  1968       1    1.9 
2 1968-01-02   135  1.71    NA  3.21   162  6.1   1968       2    3.61
3 1968-01-03   134  1.62    NA  2.8    157  5.61  1968       3    5.23
4 1968-01-04   133  1.52    NA  2.64   153  5.36  1968       4    6.75
5 1968-01-05   132  1.43    NA  2.48   147  4.83  1968       5    8.18
6 1968-01-06   140  2.19    NA  4.87   184  7.76  1968       6   10.4 </code></pre>
</div>
</div>
<p>Hier haben wir das Paket <code>dplyr</code> verwendet. Das Paket <code>dplyr</code> nutzt das sogenannte “Pipe”-Symbol <code>|&gt;</code>, um das Ergebnis einer Funktion direkt an die nächste Funktion zu übergeben. Denken Sie an das Pipe-Symbol <code>|&gt;</code> als das Wort “dann”. Sie können die Funktion folgendermaßen interpretieren: Nehmen Sie den Datensatz <code>schorgast</code>, dann verwenden Sie <code>group_by()</code>, um Gruppen zu erstellen, die im gleichen <code>jahr</code> liegen, dann verwenden Sie <code>mutate()</code>, um eine neue Spalte namens <code>summeQ1</code> zu erstellen, die die kumulative Summe (<code>cumsum()</code>) der Spalte <code>Q1</code> innerhalb jeder Gruppe (<code>jahr</code>) darstellt.</p>
<p>Nun können wir die Summenkurve für ein beliebiges Jahr plotten, hier für 2009:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(summeQ1 <span class="sc">~</span> Datum, <span class="at">data =</span> schorgast, <span class="at">subset =</span> jahr<span class="sc">==</span><span class="dv">2009</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-cumsum-year-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<section id="aufgabe-5" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-5">Aufgabe 5</h2>
<ul>
<li>Plotten Sie die Summenkurve für Station 2 (Q2) für das Jahr 2006. Zuerst müssen Sie die kumulative Summe berechnen, wie oben für Station 1 (Q1) gezeigt.</li>
</ul>
<p>Die Funktion <code>ggplot()</code> bietet einige nützliche Funktionen, um mehrere Linien zu visualisieren. Hier möchten wir mehrere Jahre zusammen betrachten, um einen Vergleich anzustellen. Zuerst konvertieren wir die Spalte <code>jahr</code> in einen Faktor, um die Darstellung im Plot zu verbessern. Anschließend erstellen wir eine Teilmenge der Daten für die Jahre 1990–2001, damit die Plots übersichtlicher bleiben. Danach plotten wir die Teilmenge der Daten und setzen <code>colour = jahr</code>, sodass ggplot jede Linie eines Jahres separat darstellt. Mit <code>theme_minimal()</code> wird der graue Standardhintergrund entfernt und einige andere Details vereinfacht.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># change 'jahr' to a factor</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>schorgast<span class="sc">$</span>jahr <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(schorgast<span class="sc">$</span>jahr)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># create a subset of the data for years 1990 - 2001</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>schorgast_sub <span class="ot">&lt;-</span> <span class="fu">subset</span>(schorgast, jahr <span class="sc">%in%</span> <span class="dv">1990</span><span class="sc">:</span><span class="dv">2001</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the data, each year in a different colour</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> schorgast_sub) <span class="sc">+</span> </span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> jahrtag, <span class="at">y =</span> summeQ1, <span class="at">colour =</span> jahr)) <span class="sc">+</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-all-cumsums-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Eine weitere Möglichkeit, ansprechende Plots zu erstellen, besteht darin, für jedes Jahr ein separates Panel zu erstellen. Dies erreichen wir mit der Funktion <code>facet_wrap()</code>. Wir weisen <code>facet_wrap()</code> an, für jedes Jahr ein neues Panel zu erstellen (<code>~ jahr</code>) und die Skalen in jedem Panel konstant zu halten (<code>scales = "fixed"</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the data again, this time each year in a panel</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> schorgast_sub) <span class="sc">+</span> </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> jahrtag, <span class="at">y =</span> summeQ1)) <span class="sc">+</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>jahr, <span class="at">scales =</span> <span class="st">"fixed"</span>) <span class="sc">+</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-cumsums3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="aufgabe-6" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-6">Aufgabe 6</h2>
<p>Betrachten Sie die obigen Plots:</p>
<ul>
<li>Welches war das nasseste Jahr?</li>
<li>Welches war das trockenste Jahr?</li>
<li>Welches Jahr hatte den nassesten Herbst? Denken Sie daran, dass steile Teile der Kurve den höchsten Abfluss anzeigen.</li>
</ul>
</section>
</section>
<section id="abschätzung-des-abflusses-an-nicht-gemessenen-standorten" class="level1">
<h1>Abschätzung des Abflusses an nicht gemessenen Standorten</h1>
<section id="verwendung-der-einzugsgebietsflächen" class="level2">
<h2 class="anchored" data-anchor-id="verwendung-der-einzugsgebietsflächen">Verwendung der Einzugsgebietsflächen</h2>
<p>Hydrologische Pegelstationen befinden sich selten genau an dem Ort, den Sie für Ihr Bauprojekt benötigen. In solchen Fällen ist es notwendig, den Abfluss von einem anderen Standort abzuschätzen oder anzupassen. Zum Beispiel müssen Sie möglicherweise den Abfluss an Punkt B abschätzen, indem Sie die Daten von Station 2 verwenden, die die nächste Station ist.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../figs/schorgast-untersteinach2.png" class="center img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Flussnetz und Standort der hydrologischen Stationen</figcaption>
</figure>
</div>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Eigenschaften der Pegelstationen</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Pegelstation</th>
<th style="text-align: right;">EZG.km2</th>
<th style="text-align: left;">Gewaesser</th>
<th style="text-align: left;">Ort</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Station 1</td>
<td style="text-align: right;">77.2</td>
<td style="text-align: left;">Schorgast</td>
<td style="text-align: left;">Wirsberg</td>
</tr>
<tr class="even">
<td style="text-align: left;">Station 2</td>
<td style="text-align: right;">137.4</td>
<td style="text-align: left;">Untere Steinach</td>
<td style="text-align: left;">Untersteinach</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Station 3</td>
<td style="text-align: right;">244.4</td>
<td style="text-align: left;">Schorgast</td>
<td style="text-align: left;">Untersteinach</td>
</tr>
<tr class="even">
<td style="text-align: left;">Punkt A</td>
<td style="text-align: right;">91.7</td>
<td style="text-align: left;">Schorgast</td>
<td style="text-align: left;">Zwischen 1 und 3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Punkt B</td>
<td style="text-align: right;">112.1</td>
<td style="text-align: left;">Untere Steinach</td>
<td style="text-align: left;">Oberhalb von Station 2</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Um dies zu tun, können Sie den gemessenen Abfluss proportional zur Größe der Einzugsgebietsflächen (<span class="math inline">\(A_E\)</span>) an jedem Standort skalieren.</p>
<p><span class="math display">\[
Q_B = Q_2 \frac{A_B}{A_2}
\]</span></p>
<p>wobei <span class="math inline">\(Q_B\)</span> und <span class="math inline">\(Q_2\)</span> der Abfluss an Punkt B bzw. Station 2 sind, und <span class="math inline">\(A_B\)</span> und <span class="math inline">\(A_2\)</span> die Einzugsgebietsflächen an Punkt B bzw. Station 2 darstellen.</p>
<p>Verwenden Sie die Daten in der obigen Tabelle:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>schorgast<span class="sc">$</span>QB <span class="ot">&lt;-</span> schorgast<span class="sc">$</span>Q2 <span class="sc">*</span> <span class="fl">112.1</span> <span class="sc">/</span> <span class="fl">137.4</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the result</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(QB <span class="sc">~</span> Datum, schorgast, <span class="at">subset =</span> jahr <span class="sc">==</span> <span class="dv">1989</span>, </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">main =</span> <span class="st">"QB - 1989"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/calc-QB-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="aufgabe-7" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-7">Aufgabe 7</h2>
<ul>
<li><p>Verwenden Sie die in der Tabelle angegebenen Einzugsgebietsflächen, um den Abfluss an Punkt A basierend auf den gemessenen Abflüssen an Station 1 abzuschätzen. Fügen Sie diese Daten dem <code>data.frame</code> <code>schorgast</code> als neue Spalte mit dem Namen <code>QA</code> hinzu.</p></li>
<li><p>Sie könnten auch eine der anderen Stationen verwenden. Welche halten Sie für am besten geeignet?</p></li>
</ul>
</section>
<section id="verwendung-eines-regressionsansatzes" class="level2">
<h2 class="anchored" data-anchor-id="verwendung-eines-regressionsansatzes">Verwendung eines Regressionsansatzes</h2>
<p>Vielleicht haben Sie bereits einige Abflussdaten an dem Standort, der Sie interessiert. In diesem Fall können Sie die Korrelation zwischen dem Abfluss an Ihrem Interessensstandort und den gemessenen Abflüssen an einem anderen Standort mit einer Pegelstation nutzen.</p>
<p>In diesem Beispiel schätzen wir den Abfluss an Station 3 (Q3) basierend auf den Abflüssen an Stationen 1 (Q1) und 2 (Q2). Tatsächlich haben wir an Station 3 gemessene Daten, sodass wir dies in der Praxis nicht tun müssten, aber wir machen es dennoch, um zu testen, wie gut unsere Methode ist. Es macht Sinn, sowohl Station 1 als auch Station 2 zu verwenden, da der Abfluss an Station 3 nahe an der Summe beider Abflüsse liegen sollte, was uns eine bessere Schätzung liefert.</p>
<p>In R ist es einfach, eine einfache lineare Regression mit der Funktion <code>lm(y ~ x, data = meinedaten)</code> durchzuführen. Hier ist <code>y</code> die abhängige Variable, also die, die wir schätzen möchten, und <code>x</code> die unabhängige Variable, also die, die uns bei der Vorhersage hilft. <code>y</code> und <code>x</code> sind die Namen der Spalten in <code>meinedaten</code>.</p>
<p>Eine multiple Regression mit mehr als einer unabhängigen Variable, zum Beispiel <code>x1</code> und <code>x2</code>, ist in R ebenfalls sehr einfach. Sie sieht so aus: <code>lm(y ~ x1 + x2, data = meinedaten)</code>.</p>
<p>Wir können daher Q3 (abhängige Variable) aus Q1 und Q2 (unabhängige Variablen) folgendermaßen schätzen:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>reg <span class="ot">&lt;-</span> <span class="fu">lm</span>(Q3 <span class="sc">~</span> Q1 <span class="sc">+</span> Q2, <span class="at">data =</span> schorgast)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Die Ergebnisse können wir mit der Funktion <code>summary()</code> betrachten.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(reg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = Q3 ~ Q1 + Q2, data = schorgast)

Residuals:
     Min       1Q   Median       3Q      Max 
-18.3370  -0.1842   0.0263   0.1889  21.8209 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -0.164524   0.008880  -18.53   &lt;2e-16 ***
Q1           1.362386   0.013070  104.23   &lt;2e-16 ***
Q2           1.045992   0.004819  217.07   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.7561 on 17895 degrees of freedom
Multiple R-squared:  0.9635,    Adjusted R-squared:  0.9635 
F-statistic: 2.365e+05 on 2 and 17895 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>Die Zusammenfassungstabelle liefert wichtige Informationen über die Regression. Die Regressionskoeffizienten befinden sich in der Spalte “Estimate”. Der T-Statistik-Wert ist in der Spalte “t value” angegeben. Er zeigt, dass alle Koeffizienten hochsignifikant sind, mit sehr niedrigen p-Werten, die in der Spalte “Pr(&gt;|t|)” angegeben sind. Der “R-squared”-Wert zeigt, dass unsere Regression mehr als 96% der Varianz erklärt, was sehr gut ist.</p>
<p>Plotten wir die Daten für ein Jahr (zum Beispiel 1980), um zu sehen, wie gut unsere Schätzung von Q3 ist. Wir verwenden die Funktion <code>predict()</code>, um die Ausgabe der Regression zu berechnen, und fügen sie als Spalte zum Datensatz <code>schorgast</code> hinzu. Wenn wir <code>predict()</code> verwenden, geben wir <code>newdata = schorgast</code> an, was der Funktion mitteilt, dass sie in <code>schorgast</code> nach Spalten mit den Namen der unabhängigen Variablen (Q1 und Q2) suchen soll, und dann diese Variablen verwendet, um Q3 mit der Regression vorherzusagen.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># add predicted values to schorgast</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>schorgast<span class="sc">$</span>Q3_predicted <span class="ot">&lt;-</span> <span class="fu">predict</span>(reg, <span class="at">newdata =</span> schorgast)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the original data in black</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Q3 <span class="sc">~</span> Datum, schorgast, <span class="at">subset =</span> jahr <span class="sc">==</span> <span class="dv">1980</span>, <span class="at">type =</span> <span class="st">"l"</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="co"># add the predicted values</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Q3_predicted <span class="sc">~</span> Datum, schorgast, <span class="at">col =</span> <span class="st">"red"</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="co"># add a legend</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="fu">c</span>(<span class="st">"measured"</span>, <span class="st">"predicted"</span>), <span class="at">lty=</span><span class="dv">1</span>, <span class="at">col =</span> <span class="fu">c</span>(<span class="st">"black"</span>, <span class="st">"red"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung5_de_files/figure-html/plot-reg-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Gar nicht so schlecht.</p>
</section>
<section id="aufgabe-8-hacker-aufgabe---optional" class="level2">
<h2 class="anchored" data-anchor-id="aufgabe-8-hacker-aufgabe---optional">Aufgabe 8 (Hacker-Aufgabe - optional)</h2>
<ul>
<li><p>führen Sie den Befehl <code>plot(reg)</code> aus. Sie müssen immer eine Taste drücken, um den nächsten Plot anzuzeigen. Was zeigen diese Plots? Wir können sie in der Gruppe diskutieren.</p></li>
<li><p>Schätzen Sie den Abfluss an Station 2 (abhängige Variabel ist Q2) anhand der Abflussdaten an Station 1 (unabhängige Variabel ist Q1). Vergleichen Sie die geschätzten und gemessenen Daten in einem Plot. Ist die Schätzung genauso gut wie für Station 1?</p></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>