<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Hydrologie und Wasserbau Uebung4 - Abfluss</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="uebung4_files/libs/clipboard/clipboard.min.js"></script>
<script src="uebung4_files/libs/quarto-html/quarto.js"></script>
<script src="uebung4_files/libs/quarto-html/popper.min.js"></script>
<script src="uebung4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="uebung4_files/libs/quarto-html/anchor.min.js"></script>
<link href="uebung4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="uebung4_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="uebung4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="uebung4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="uebung4_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Hydrologie und Wasserbau Uebung4 - Abfluss</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="einführung" class="level1">
<h1>Einführung</h1>
<p>In der ersten Aufgabe werden Sie die Hydrologie der Elbe charakterisieren. Die Schritte umfassen zunächst das Importieren der Daten in R und dann die Visualisierung der Daten. Anschließend berechnen Sie aussagekräftige statistische Kenngrößen, einschließlich NNQ, NQ, MNQ, MQ, MHQ, HQ und HHQ.</p>
<p>In der zweiten Aufgabe werden Sie den Abfluss in einem Bach anhand einer Tracermessung berechnen.</p>
<p>Die Übungen erfordern Ihre R-Kenntnisse, und Sie werden wahrscheinlich mit der Syntax Schwierigkeiten haben. Verwenden Sie das Spickzettel, fragen Sie mich um Hilfe oder stellen Sie ChatGPT gezielte Fragen, falls Sie nicht weiterkommen, zum Beispiel: „Ich versuche, Daten in R einzulesen. Warum funktioniert dieser Code nicht: <code>&lt;Code hier angeben&gt;</code>?”</p>
<p>Diese Übung basiert auf einer ähnlichen Übung von Thomas Petzoldt (TU-Dresden, <a href="https://github.com/tpetzoldt" class="uri">https://github.com/tpetzoldt</a>). Die ursprüngliche Übung finden Sie hier: <a href="https://tpetzoldt.github.io/element-labs/qmd/03-discharge-elbe.html" class="uri">https://tpetzoldt.github.io/element-labs/qmd/03-discharge-elbe.html</a>. Diese Arbeit wird dankend anerkannt.</p>
<section id="der-datensatz" class="level2">
<h2 class="anchored" data-anchor-id="der-datensatz">Der Datensatz</h2>
<p>Der Datensatz besteht aus täglichen Messungen des Abflusses der Elbe in Dresden (tägliche Abflusssumme in <span class="math inline">\(\mathrm{m^3 s^{-1}}\)</span>). Die Daten wurden freundlicherweise vom deutschen Bundesanstalt für Gewässerkunde (BfG) zur Verfügung gestellt. Bitte lesen Sie die Informationsdatei elbe_info.txt über die Datenquelle und das Copyright, bevor Sie die Datei data.csv herunterladen. Der Datensatz ist dann im Kursordner auf ILIAS oder verfügbar unter https://github.com/tpetzoldt/datasets/blob/main/data/.)</p>
</section>
<section id="packages" class="level2">
<h2 class="anchored" data-anchor-id="packages">Packages</h2>
<p>Sind alle nötigen Packages installiert, müssen sie einmal in jedem neuen R-Session geladen werden.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readr)     <span class="co"># modernized functions to read rectangular data like csv</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)     <span class="co"># the most essential tidyverse packages</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)     <span class="co"># contains for example pivot tables</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lubridate) <span class="co"># a tidyverse package for dates</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)   <span class="co"># high level plotting with the grammar of graphics</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="aufgabe-1-elbe" class="level1">
<h1>Aufgabe 1: Elbe</h1>
<p>In dieser Übung werden Sie Abflussdaten der Elbe in R einlesen, die Daten visualisieren und die wichtigen statistischen Kenngrößen NNQ, NQ, MNQ, MQ, MHQ, HQ und HHQ berechnen.</p>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Kenngrößen des Abflusses</caption>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Bezeichnung</th>
<th style="text-align: left;">Erklaerung</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">NNQ</td>
<td style="text-align: left;">Niedrigste Niedrigwasserabfluss seit Beobachtungsbeginn</td>
</tr>
<tr class="even">
<td style="text-align: left;">NQ</td>
<td style="text-align: left;">Niedrigwasserabfluss. Niedrigster Wert einer Jahresreihe</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MNQ</td>
<td style="text-align: left;">Mittelwert des NQ</td>
</tr>
<tr class="even">
<td style="text-align: left;">MQ</td>
<td style="text-align: left;">Mittlere Abfluss. Arithmetische Mittel aller Beobachtungen</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MHQ</td>
<td style="text-align: left;">Mittlerer Hochwasserabfluss. Mittelwert des HQ</td>
</tr>
<tr class="even">
<td style="text-align: left;">HQ</td>
<td style="text-align: left;">Hochwasserabfluss. Oberer Wert einer Jahresreihe</td>
</tr>
<tr class="odd">
<td style="text-align: left;">HHQ</td>
<td style="text-align: left;">Hoechster Hochwasserabfluss. Oberster bislang beobachteter Wert</td>
</tr>
</tbody>
</table>
</div>
</div>
<section id="a-daten-einlesen" class="level2">
<h2 class="anchored" data-anchor-id="a-daten-einlesen">A) Daten einlesen</h2>
<p>Bevor Sie die Elbeabflussdaten <code>elbe.csv</code> einlesen, schauen Sie sich die Daten erst mit einem Texteditor an. Gibt es Header? Sind die Spaltenüberschriften in Ordnung oder enthalten sie Sonder- oder Leerzeichen? Welche Formate haben die Daten?</p>
<p>Prüfen Sie auch Ihren Arbeitsverzeichnis mit dem Befehl <code>getwd()</code>. Wo ist <code>elbe.csv</code> relativ zum Arbeitsverzeichnis gespeichert?</p>
<p>Sieht alles okay aus, verwenden Sie die Funktion <code>read.csv()</code> im base R Package, oder alternativ dazu die Funktion <code>read_csv()</code> im Package <code>readr</code>, um die Daten einzulesen. Als Argument in den Klammern müssen Sie den Pfad zu der Datei - relativ zu Ihrem Arbeitsverzeichnis - in Anfürhungszeichen angeben. Zum Beispiel, <code>read_csv("../Daten/elbe.csv")</code> bedeutet, gehe eine Ebene höher als mein Arbeitsverzeichnis, dann gehe in den Verzeichnis “Daten”, dann lese “elbe.csv”.</p>
<p>Geben Sie mit dem Zuweisungsoperator den eingelesenen Daten einen Namen (z.B. “elbe”) <code>elbe &lt;- read_csv()</code>. Wenn Sie <code>read_csv()</code> verwenden, muss das Paket <code>readr</code> erst einmal geladen werden mit <code>library(readr)</code>. Der Vorteil von <code>read_csv()</code> ist, dass Datumsangaben automatisch erkannt werden.</p>
<p>Wenn Sie Schwierigkeiten haben, die Daten einzulesen, können Sie natürlich die Daten manuell einlesen, und zwar in RStudio über dem Menüpunkt “File/Datei” –&gt; “Import dataset”.</p>
</section>
<section id="b-visualisieren-sie-die-daten" class="level2">
<h2 class="anchored" data-anchor-id="b-visualisieren-sie-die-daten">B) Visualisieren Sie die Daten</h2>
<p>Schauen Sie sich die Daten in R an. Nutzen Sie Funktionen wie <code>View(elbe)</code>, <code>head(elbe)</code>, <code>tail(elbe)</code>, <code>str(elbe)</code>, oder klicken Sie auf <code>elbe</code> in Ihrem Environment im Panel oben rechts in RStudio.</p>
<p>Welche <code>class</code> haben die einzelnen Spalten? Passt das zu den Daten? Wenn die erste Spalte die <code>class</code> “character” hat, muss sie in ein Datum konvertiert werden. Sie können das mit der Funktion <code>as.POSIXct()</code> im Base-R-Package, oder beispielsweise mit der Funktion <code>as_date()</code> im Package <code>lubridate</code>, die zuerst mit <code>library(lubridate)</code> geladen werden müsste.</p>
<p>Plotten Sie die Daten, mit Zeit auf der x-Achse und Abfluss auf der y-Achse. Nutzen Sie entweder die Base-R-Funktion <code>plot()</code> oder die Funktion <code>ggplot()</code> aus dem Package <code>ggplot2</code>, der zuerst geladen werden müsste. Für <code>plot()</code> würde der Syntax ungefähr so aussehen:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(YSPALTE <span class="sc">~</span> XSPALTE, <span class="at">data =</span> elbe, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Für <code>ggplot</code>gibt es ein getrennter Cheat-Sheet im Projektordner auf ILIAS, und die Funktion würde ungefähr so aussehen:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> elbe) <span class="sc">+</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> XSPALTE, <span class="at">y =</span> YSPALTE))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Können Sie schon visuell NNQ, NQ, MNQ, MQ, MHQ, HQ and HHQ abschätzen?</p>
<p>Mit Base-R:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung4_files/figure-html/plot-elbe-data4real-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Mit ggplot:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung4_files/figure-html/ggplot-elbe-data4real-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="c-berechnen-sie-nnq-mq-und-hhq" class="level2">
<h2 class="anchored" data-anchor-id="c-berechnen-sie-nnq-mq-und-hhq">C) Berechnen Sie NNQ, MQ, und HHQ</h2>
<p>Die Kenngrößen, die sich aus der ganzen Zeitreihe ableiten, lassen sich relativ einfach berechnen. Hierzu benutzen Sie Funktionen wie <code>min()</code>, <code>max()</code>, <code>mean()</code> oder <code>summary()</code>. Als Argument (das was innerhalb der Klammern kommt) geben Sie den Abfluss an</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   74.2   154.0   224.0   302.0   360.0  4500.0 </code></pre>
</div>
</div>
<p><strong>Bonusaufgabe</strong> (Schwieriger): an welchem Tag sind HHQ und NNQ vorgekommen? Hierzu könnten Sie logische Werte als Indizes benutzen, oder auch eine Funktion wie <code>which.min()</code> oder <code>which.max()</code>, um die entsprechenden Zeile mit dem Minimum- bzw. Maximumwerten auszuwählen.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "NNQ:"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2018-08-23 UTC"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "HHQ:"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2002-08-17 UTC"</code></pre>
</div>
</div>
</section>
<section id="d-berechnen-sie-nq-mnq-mhq-hq-bezogen-auf-die-kalenderjahre" class="level2">
<h2 class="anchored" data-anchor-id="d-berechnen-sie-nq-mnq-mhq-hq-bezogen-auf-die-kalenderjahre">D) Berechnen Sie NQ, MNQ, MHQ, HQ bezogen auf die Kalenderjahre</h2>
<p>NQ, MNQ, MHQ, HQ sind etwas schwieriger als HHQ, MQ und NNQ, weil sie sich nicht auf die gesamte Reihe beziehen, sondern müssen aus Teilmengen der Daten (die einzelnen Jahre) berechnet werden.</p>
<p>Damit das funktioniert, müssen Sie zuerst eine neue Spalte in Ihrem data.frame kreieren, die eine Gruppierungsvariabel enthält. In diesem Fall ist das Gruppierungsvariabel das Kalenderjahr. Das <code>lubridate</code>-Package beinhaltet Funktionen, die dafür geeignet sind. Beispielsweise gibt die Funktion <code>year()</code> das Jahr aus, wenn ein Datum innerhalb der Klammern als Argument angeben wird. Ein Weg geht so:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>elbe<span class="sc">$</span>jahr <span class="ot">&lt;-</span> <span class="fu">year</span>(elbe<span class="sc">$</span>date)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(elbe)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        date discharge validated jahr
1 1989-01-01       765      TRUE 1989
2 1989-01-02       713      TRUE 1989
3 1989-01-03       684      TRUE 1989
4 1989-01-04       612      TRUE 1989
5 1989-01-05       565      TRUE 1989
6 1989-01-06       519      TRUE 1989</code></pre>
</div>
</div>
<p>R hat sehr leistungsfähige Funktionen, um Statistiken von gruppierten Daten zu berechnen. Eine dieser Funktionen im Base-R ist <code>aggregate()</code> und sieht ungefähr so aus:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>jahresNQ <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(DATASPALTE <span class="sc">~</span> GRUPPIERSPALTE, <span class="at">data =</span> elbe, <span class="at">FUN =</span> min)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "NQ"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>  jahr discharge
1 1989       122
2 1990        89
3 1991        97
4 1992        89
5 1993        92
6 1994        92</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>   jahr discharge
26 2014      94.8
27 2015      79.9
28 2016      92.5
29 2017      93.5
30 2018      74.2
31 2019      78.8</code></pre>
</div>
</div>
<p><code>FUN</code> ist eine Funktion wie <code>mean</code>, <code>max</code>, usw. <code>jahresmittel</code>ist ein neuer <code>data.frame</code>, der die entsprechenden Statistiken für jede eindeutige Gruppe enthält, in unserem Fall, die Statistiken für jedes Jahr in der Datenreihe. Durch die Angabe von <code>mean</code> werden die Mittelwerte ausgegeben. Wollen Sie die jeweiligen Maximum- oder Minimumwerte, nutzen Sie <code>FUN = min</code> oder <code>FUN = max</code>.</p>
<p>Anschliessend können Sie die Mittelwerte der Jahresminima und -maxima berechnen.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>MNQ <span class="ot">&lt;-</span> <span class="fu">mean</span>(NQ<span class="sc">$</span>discharge)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>MNQ</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 105.4935</code></pre>
</div>
</div>
<p>Berechnen Sie analog dazu auch MHQ.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  jahr discharge
1 1989       765
2 1990       885
3 1991       634
4 1992      1090
5 1993      1610
6 1994      1030</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>   jahr discharge
26 2014       664
27 2015      1010
28 2016       606
29 2017       802
30 2018       679
31 2019       783</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "MHQ"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1434.129</code></pre>
</div>
</div>
<p><strong>Hacker-Aufgabe</strong> (Experte): Berechnen Sie NQ, MNQ, MHQ, HQ, aber diesmal auf das hydrologische Jahr (1. November bis 31. Oktober) bezogen. Gehen Sie so vor:</p>
<ul>
<li><p>Kreieren Sie eine neue Spalte mit dem jeweiligen Monat der Messung und nennen Sie die Spalte “Monat”. Hierzu nutzen Sie die Funktion <code>month()</code> analog zum Jahr oben.</p></li>
<li><p>Nutzen Sie anschliessend wieder logische Werte als Indizes, um die entsprechenden Zeilen auszuwählen. Die logische Frage lautet: “Ist der Monat gleich (<code>==</code>) 11 oder (<code>|</code>) ist der Monat gleich (<code>==</code>) 12, dann wähle die Werte in der Spalte”Jahr” aus und ersetze diesen durch den ursprünglichen Wert + 1”. So beziehen sich die Werte in der Spalte Jahr nicht mehr auf das Kalenderjahr, sondern nun auf das hydrologische Jahr.</p></li>
<li><p>Berechnen Sie NQ, MNQ, MHQ, HQ analog zur obigen Aufgabe. Wenden Sie wieder die Funktionen <code>mean()</code>, <code>max()</code>, <code>min()</code>, oder <code>summary()</code>, auf die neuen data.frames <code>jahresmittel</code> oder wie Sie sie genannt haben.</p></li>
</ul>
</section>
</section>
<section id="aufgabe-2-abflussberechnung-mit-tracer-messung" class="level1">
<h1>Aufgabe 2: Abflussberechnung mit Tracer-Messung:</h1>
<p>Um den Abfluss im Kaltenbach zu berechnen, wurde eine Tracer-Messung durchgeführt. 5 kg eines Tracers wurde im Bach zum Zeitpunkt t = 0 gekippt. An einer entsprechenden Stelle im Unterlauf (Komplettmischung des Tracers) wurde die Konzentration im Wasser (<span class="math inline">\(\mathrm{kg m^{-3}}\)</span>) zeitlich hochaufgelöst gemessen.</p>
<p>Für die ersten 10 Minuten wurden die Hintergundkonzentration C0 gemessen. Ab den 10. Minute wurde der erste Anstieg in der Konzentration registriert. Die Konzentration hat den Hintergrundkonzentration nach 20 Minuten vollständig wieder erreicht.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/tracer.png" class="img-fluid figure-img"></p>
<figcaption>Tracer addition measurement</figcaption>
</figure>
</div>
<p><strong>Berechnen Sie den Abfluss.</strong></p>
<section id="a-daten-einlesen-und-visualisieren" class="level2">
<h2 class="anchored" data-anchor-id="a-daten-einlesen-und-visualisieren">A) Daten einlesen und visualisieren</h2>
<p>Lesen Sie die Datei <code>tracer.csv</code> ein. Plotten Sie die Daten. Schätzen Sie visuell die Hintergrundkonzentration C0.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  time       conc
1  0.0 0.07973050
2  0.1 0.10079005
3  0.2 0.09660810
4  0.3 0.09342133</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>    time      conc
199 19.7 0.1192637
200 19.8 0.1021879
201 19.9 0.1136486
202 20.0 0.1176859</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung4_files/figure-html/read-data-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="b-hintergrundkonzentration-berechnen" class="level2">
<h2 class="anchored" data-anchor-id="b-hintergrundkonzentration-berechnen">B) Hintergrundkonzentration berechnen</h2>
<p>Berechnen Sie die Hintergrundkonzentration C0 (Mittelwert der ersten 10 Minuten).</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "C0"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.09996476</code></pre>
</div>
</div>
</section>
<section id="c-hintergrundkonzentration-abziehen" class="level2">
<h2 class="anchored" data-anchor-id="c-hintergrundkonzentration-abziehen">C) Hintergrundkonzentration abziehen</h2>
<p>Ziehen Sie die Hintergrundkonzentration C0 von der Messreihe ab.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="uebung4_files/figure-html/CC0-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="d-zeitschritt" class="level2">
<h2 class="anchored" data-anchor-id="d-zeitschritt">D) Zeitschritt</h2>
<p>Ermitteln Sie den Zeitschritt dt zwischen der Messungen.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>dt <span class="ot">&lt;-</span> tracer[<span class="dv">2</span>, <span class="st">"time"</span>] <span class="sc">-</span> tracer[<span class="dv">1</span>, <span class="st">"time"</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>dt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.1</code></pre>
</div>
</div>
</section>
<section id="e-konzentration-integrieren" class="level2">
<h2 class="anchored" data-anchor-id="e-konzentration-integrieren">E) Konzentration integrieren</h2>
<p>Integrieren Sie die Tracer-Konzentration über die Zeit:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.000862</code></pre>
</div>
</div>
</section>
<section id="f-abfluss-berechnen" class="level2">
<h2 class="anchored" data-anchor-id="f-abfluss-berechnen">F) Abfluss berechnen</h2>
<p>Berechnen Sie den Abfluss des Kaltenbachs. Die Formel für den Abfluss, mit einer zugegebenen Tracer-Masse von K und gemessenen Konzentration k lautet:</p>
<p><span class="math display">\[
Q = \frac{K}{\int k \, dt}~[m^3~s^{-1}]
\]</span></p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.995692</code></pre>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>