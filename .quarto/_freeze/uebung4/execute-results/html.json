{
  "hash": "4986f44a76f61e793d37d61e8e886555",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hydrologie und Wasserbau Uebung4 - Abfluss\"\nformat: html\neditor: visual\n---\n\n\n\n\n\n# Einführung\n\nIn der ersten Aufgabe werden Sie die Hydrologie der Elbe charakterisieren. Die Schritte umfassen zunächst das Importieren der Daten in R und dann die Visualisierung der Daten. Anschließend berechnen Sie aussagekräftige statistische Kenngrößen, einschließlich NNQ, NQ, MNQ, MQ, MHQ, HQ und HHQ.\n\nIn der zweiten Aufgabe werden Sie den Abfluss in einem Bach anhand einer Tracermessung berechnen.\n\nDie Übungen erfordern Ihre R-Kenntnisse, und Sie werden wahrscheinlich mit der Syntax Schwierigkeiten haben. Verwenden Sie das Spickzettel, fragen Sie mich um Hilfe oder stellen Sie ChatGPT gezielte Fragen, falls Sie nicht weiterkommen, zum Beispiel: „Ich versuche, Daten in R einzulesen. Warum funktioniert dieser Code nicht: `<Code hier angeben>`?\"\n\nDiese Übung basiert auf einer ähnlichen Übung von Thomas Petzoldt (TU-Dresden, <https://github.com/tpetzoldt>). Die ursprüngliche Übung finden Sie hier: <https://tpetzoldt.github.io/element-labs/qmd/03-discharge-elbe.html>. Diese Arbeit wird dankend anerkannt.\n\n## Der Datensatz\n\nDer Datensatz besteht aus täglichen Messungen des Abflusses der Elbe in Dresden (tägliche Abflusssumme in $\\mathrm{m^3 s^{-1}}$). Die Daten wurden freundlicherweise vom deutschen Bundesanstalt für Gewässerkunde (BfG) zur Verfügung gestellt. Bitte lesen Sie die Informationsdatei elbe_info.txt über die Datenquelle und das Copyright, bevor Sie die Datei data.csv herunterladen. Der Datensatz ist dann im Kursordner auf ILIAS oder verfügbar unter https://github.com/tpetzoldt/datasets/blob/main/data/.)\n\n## Packages\n\nSind alle nötigen Packages installiert, müssen sie einmal in jedem neuen R-Session geladen werden.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)     # modernized functions to read rectangular data like csv\nlibrary(dplyr)     # the most essential tidyverse packages\nlibrary(tidyr)     # contains for example pivot tables\nlibrary(lubridate) # a tidyverse package for dates\nlibrary(ggplot2)   # high level plotting with the grammar of graphics\n```\n:::\n\n\n\n# Aufgabe 1: Elbe\n\nIn dieser Übung werden Sie Abflussdaten der Elbe in R einlesen, die Daten visualisieren und die wichtigen statistischen Kenngrößen NNQ, NQ, MNQ, MQ, MHQ, HQ und HHQ berechnen.\n\n\n\n::: {.cell tbl-cap='Kenngrößen des Abflusses'}\n::: {.cell-output-display}\n\n\n|Bezeichnung |Erklaerung                                                      |\n|:-----------|:---------------------------------------------------------------|\n|NNQ         |Niedrigste Niedrigwasserabfluss seit Beobachtungsbeginn         |\n|NQ          |Niedrigwasserabfluss. Niedrigster Wert einer Jahresreihe        |\n|MNQ         |Mittelwert des NQ                                               |\n|MQ          |Mittlere Abfluss. Arithmetische Mittel aller Beobachtungen      |\n|MHQ         |Mittlerer Hochwasserabfluss. Mittelwert des HQ                  |\n|HQ          |Hochwasserabfluss. Oberer Wert einer Jahresreihe                |\n|HHQ         |Hoechster Hochwasserabfluss. Oberster bislang beobachteter Wert |\n\n\n:::\n:::\n\n\n\n## A) Daten einlesen\n\nBevor Sie die Elbeabflussdaten `elbe.csv` einlesen, schauen Sie sich die Daten erst mit einem Texteditor an. Gibt es Header? Sind die Spaltenüberschriften in Ordnung oder enthalten sie Sonder- oder Leerzeichen? Welche Formate haben die Daten?\n\nPrüfen Sie auch Ihren Arbeitsverzeichnis mit dem Befehl `getwd()`. Wo ist `elbe.csv` relativ zum Arbeitsverzeichnis gespeichert?\n\nSieht alles okay aus, verwenden Sie die Funktion `read.csv()` im base R Package, oder alternativ dazu die Funktion `read_csv()` im Package `readr`, um die Daten einzulesen. Als Argument in den Klammern müssen Sie den Pfad zu der Datei - relativ zu Ihrem Arbeitsverzeichnis - in Anfürhungszeichen angeben. Zum Beispiel, `read_csv(\"../Daten/elbe.csv\")` bedeutet, gehe eine Ebene höher als mein Arbeitsverzeichnis, dann gehe in den Verzeichnis \"Daten\", dann lese \"elbe.csv\".\n\nGeben Sie mit dem Zuweisungsoperator den eingelesenen Daten einen Namen (z.B. \"elbe\") `elbe <- read_csv()`. Wenn Sie `read_csv()` verwenden, muss das Paket `readr` erst einmal geladen werden mit `library(readr)`. Der Vorteil von `read_csv()` ist, dass Datumsangaben automatisch erkannt werden.\n\nWenn Sie Schwierigkeiten haben, die Daten einzulesen, können Sie natürlich die Daten manuell einlesen, und zwar in RStudio über dem Menüpunkt \"File/Datei\" --\\> \"Import dataset\".\n\n## B) Visualisieren Sie die Daten\n\nSchauen Sie sich die Daten in R an. Nutzen Sie Funktionen wie `View(elbe)`, `head(elbe)`, `tail(elbe)`, `str(elbe)`, oder klicken Sie auf `elbe` in Ihrem Environment im Panel oben rechts in RStudio.\n\nWelche `class` haben die einzelnen Spalten? Passt das zu den Daten? Wenn die erste Spalte die `class` \"character\" hat, muss sie in ein Datum konvertiert werden. Sie können das mit der Funktion `as.POSIXct()` im Base-R-Package, oder beispielsweise mit der Funktion `as_date()` im Package `lubridate`, die zuerst mit `library(lubridate)` geladen werden müsste.\n\nPlotten Sie die Daten, mit Zeit auf der x-Achse und Abfluss auf der y-Achse. Nutzen Sie entweder die Base-R-Funktion `plot()` oder die Funktion `ggplot()` aus dem Package `ggplot2`, der zuerst geladen werden müsste. Für `plot()` würde der Syntax ungefähr so aussehen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(YSPALTE ~ XSPALTE, data = elbe, type = \"l\")\n```\n:::\n\n\n\nFür `ggplot`gibt es ein getrennter Cheat-Sheet im Projektordner auf ILIAS, und die Funktion würde ungefähr so aussehen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = elbe) +\n  geom_line(aes(x = XSPALTE, y = YSPALTE))\n```\n:::\n\n\n\nKönnen Sie schon visuell NNQ, NQ, MNQ, MQ, MHQ, HQ and HHQ abschätzen?\n\nMit Base-R:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](uebung4_files/figure-html/plot-elbe-data4real-1.png){width=672}\n:::\n:::\n\n\n\nMit ggplot:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](uebung4_files/figure-html/ggplot-elbe-data4real-1.png){width=672}\n:::\n:::\n\n\n\n## C) Berechnen Sie NNQ, MQ, und HHQ\n\nDie Kenngrößen, die sich aus der ganzen Zeitreihe ableiten, lassen sich relativ einfach berechnen. Hierzu benutzen Sie Funktionen wie `min()`, `max()`, `mean()` oder `summary()`. Als Argument (das was innerhalb der Klammern kommt) geben Sie den Abfluss an\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   74.2   154.0   224.0   302.0   360.0  4500.0 \n```\n\n\n:::\n:::\n\n\n\n**Bonusaufgabe** (Schwieriger): an welchem Tag sind HHQ und NNQ vorgekommen? Hierzu könnten Sie logische Werte als Indizes benutzen, oder auch eine Funktion wie `which.min()` oder `which.max()`, um die entsprechenden Zeile mit dem Minimum- bzw. Maximumwerten auszuwählen.\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NNQ:\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-23 UTC\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HHQ:\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2002-08-17 UTC\"\n```\n\n\n:::\n:::\n\n\n\n## D) Berechnen Sie NQ, MNQ, MHQ, HQ bezogen auf die Kalenderjahre\n\nNQ, MNQ, MHQ, HQ sind etwas schwieriger als HHQ, MQ und NNQ, weil sie sich nicht auf die gesamte Reihe beziehen, sondern müssen aus Teilmengen der Daten (die einzelnen Jahre) berechnet werden.\n\nDamit das funktioniert, müssen Sie zuerst eine neue Spalte in Ihrem data.frame kreieren, die eine Gruppierungsvariabel enthält. In diesem Fall ist das Gruppierungsvariabel das Kalenderjahr. Das `lubridate`-Package beinhaltet Funktionen, die dafür geeignet sind. Beispielsweise gibt die Funktion `year()` das Jahr aus, wenn ein Datum innerhalb der Klammern als Argument angeben wird. Ein Weg geht so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelbe$jahr <- year(elbe$date)\nhead(elbe)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        date discharge validated jahr\n1 1989-01-01       765      TRUE 1989\n2 1989-01-02       713      TRUE 1989\n3 1989-01-03       684      TRUE 1989\n4 1989-01-04       612      TRUE 1989\n5 1989-01-05       565      TRUE 1989\n6 1989-01-06       519      TRUE 1989\n```\n\n\n:::\n:::\n\n\n\nR hat sehr leistungsfähige Funktionen, um Statistiken von gruppierten Daten zu berechnen. Eine dieser Funktionen im Base-R ist `aggregate()` und sieht ungefähr so aus:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njahresNQ <- aggregate(DATASPALTE ~ GRUPPIERSPALTE, data = elbe, FUN = min)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NQ\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  jahr discharge\n1 1989       122\n2 1990        89\n3 1991        97\n4 1992        89\n5 1993        92\n6 1994        92\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   jahr discharge\n26 2014      94.8\n27 2015      79.9\n28 2016      92.5\n29 2017      93.5\n30 2018      74.2\n31 2019      78.8\n```\n\n\n:::\n:::\n\n\n\n`FUN` ist eine Funktion wie `mean`, `max`, usw. `jahresmittel`ist ein neuer `data.frame`, der die entsprechenden Statistiken für jede eindeutige Gruppe enthält, in unserem Fall, die Statistiken für jedes Jahr in der Datenreihe. Durch die Angabe von `mean` werden die Mittelwerte ausgegeben. Wollen Sie die jeweiligen Maximum- oder Minimumwerte, nutzen Sie `FUN = min` oder `FUN = max`.\n\nAnschliessend können Sie die Mittelwerte der Jahresminima und -maxima berechnen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMNQ <- mean(NQ$discharge)\nMNQ\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 105.4935\n```\n\n\n:::\n:::\n\n\n\nBerechnen Sie analog dazu auch MHQ.\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  jahr discharge\n1 1989       765\n2 1990       885\n3 1991       634\n4 1992      1090\n5 1993      1610\n6 1994      1030\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   jahr discharge\n26 2014       664\n27 2015      1010\n28 2016       606\n29 2017       802\n30 2018       679\n31 2019       783\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"MHQ\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1434.129\n```\n\n\n:::\n:::\n\n\n\n**Hacker-Aufgabe** (Experte): Berechnen Sie NQ, MNQ, MHQ, HQ, aber diesmal auf das hydrologische Jahr (1. November bis 31. Oktober) bezogen. Gehen Sie so vor:\n\n-   Kreieren Sie eine neue Spalte mit dem jeweiligen Monat der Messung und nennen Sie die Spalte \"Monat\". Hierzu nutzen Sie die Funktion `month()` analog zum Jahr oben.\n\n-   Nutzen Sie anschliessend wieder logische Werte als Indizes, um die entsprechenden Zeilen auszuwählen. Die logische Frage lautet: \"Ist der Monat gleich (`==`) 11 oder (`|`) ist der Monat gleich (`==`) 12, dann wähle die Werte in der Spalte \"Jahr\" aus und ersetze diesen durch den ursprünglichen Wert + 1\". So beziehen sich die Werte in der Spalte Jahr nicht mehr auf das Kalenderjahr, sondern nun auf das hydrologische Jahr.\n\n-   Berechnen Sie NQ, MNQ, MHQ, HQ analog zur obigen Aufgabe. Wenden Sie wieder die Funktionen `mean()`, `max()`, `min()`, oder `summary()`, auf die neuen data.frames `jahresmittel` oder wie Sie sie genannt haben.\n\n# Aufgabe 2: Abflussberechnung mit Tracer-Messung:\n\nUm den Abfluss im Kaltenbach zu berechnen, wurde eine Tracer-Messung durchgeführt. 5 kg eines Tracers wurde im Bach zum Zeitpunkt t = 0 gekippt. An einer entsprechenden Stelle im Unterlauf (Komplettmischung des Tracers) wurde die Konzentration im Wasser ($\\mathrm{kg m^{-3}}$) zeitlich hochaufgelöst gemessen.\n\nFür die ersten 10 Minuten wurden die Hintergundkonzentration C0 gemessen. Ab den 10. Minute wurde der erste Anstieg in der Konzentration registriert. Die Konzentration hat den Hintergrundkonzentration nach 20 Minuten vollständig wieder erreicht.\n\n![Tracer addition measurement](figs/tracer.png)\n\n**Berechnen Sie den Abfluss.**\n\n## A) Daten einlesen und visualisieren\n\nLesen Sie die Datei `tracer.csv` ein. Plotten Sie die Daten. Schätzen Sie visuell die Hintergrundkonzentration C0.\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  time       conc\n1  0.0 0.07973050\n2  0.1 0.10079005\n3  0.2 0.09660810\n4  0.3 0.09342133\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    time      conc\n199 19.7 0.1192637\n200 19.8 0.1021879\n201 19.9 0.1136486\n202 20.0 0.1176859\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](uebung4_files/figure-html/read-data-1.png){width=672}\n:::\n:::\n\n\n\n## B) Hintergrundkonzentration berechnen\n\nBerechnen Sie die Hintergrundkonzentration C0 (Mittelwert der ersten 10 Minuten).\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C0\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.09996476\n```\n\n\n:::\n:::\n\n\n\n## C) Hintergrundkonzentration abziehen\n\nZiehen Sie die Hintergrundkonzentration C0 von der Messreihe ab.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](uebung4_files/figure-html/CC0-1.png){width=672}\n:::\n:::\n\n\n\n## D) Zeitschritt\n\nErmitteln Sie den Zeitschritt dt zwischen der Messungen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- tracer[2, \"time\"] - tracer[1, \"time\"]\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1\n```\n\n\n:::\n:::\n\n\n\n## E) Konzentration integrieren\n\nIntegrieren Sie die Tracer-Konzentration über die Zeit:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000862\n```\n\n\n:::\n:::\n\n\n\n## F) Abfluss berechnen\n\nBerechnen Sie den Abfluss des Kaltenbachs. Die Formel für den Abfluss, mit einer zugegebenen Tracer-Masse von K und gemessenen Konzentration k lautet:\n\n$$\nQ = \\frac{K}{\\int k \\, dt}~[m^3~s^{-1}]\n$$\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.995692\n```\n\n\n:::\n:::\n",
    "supporting": [
      "uebung4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}